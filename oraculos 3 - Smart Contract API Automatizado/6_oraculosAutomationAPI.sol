// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {FunctionsClient} from "@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol";
import {FunctionsRequest} from "@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol";
import {AutomationCompatibleInterface} from "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";

contract APIPersonalizada is FunctionsClient, AutomationCompatibleInterface {
    using FunctionsRequest for FunctionsRequest.Request;

    bytes32 public ultimoRequestId;
    string public nombrePiloto;
    
    uint256 public counter; // nuevo
    uint256 public immutable interval; //nuevo
    uint256 public lastTimeStamp; // nuevo

    address ROUTER = 0xb83E47C2bC239B3bf370bc41e1459A34b41238D0;
    bytes32 DON_ID = 0x66756e2d657468657265756d2d7365706f6c69612d3100000000000000000000;
    uint32 GAS_LIMIT = 300000;


    string CODIGO_FUENTE =
        "const apiResponse = await Functions.makeHttpRequest({"
        "url: `https://mahoobox.github.io/TalentoTech/test/test.json`"
        "});"
        "if (apiResponse.error) {"
        "throw Error('Solicitud fallida');"
        "}"
        "return Functions.encodeString(apiResponse.data[0].resultado);";

    event Respuesta(
        bytes32 indexed requestId,
        string nombrePiloto
    );
    
    constructor(uint256 updateInterval) FunctionsClient(ROUTER) {
        interval = updateInterval;
        lastTimeStamp = block.timestamp;
        counter = 0;
    }


    function enviarSolicitud() internal returns (bytes32 requestId) {
        FunctionsRequest.Request memory req;
        req.initializeRequestForInlineJavaScript(CODIGO_FUENTE); // Initialize the request with JS code
        
        // Send the request and store the request ID
        ultimoRequestId = _sendRequest(
            req.encodeCBOR(),
            3299, // el ID de la suscripciÃ³n de Chainlink Functions ingresado manualmente.
            GAS_LIMIT,
            DON_ID
        );

        return ultimoRequestId;
    }

    function checkUpkeep(bytes calldata) external view override  returns (bool upkeepNeeded, bytes memory ) {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
    }

    function performUpkeep(bytes calldata) external override  {
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            counter = counter + 1;
            enviarSolicitud(); // Se invoca para que la ejecute dentro de la serie de consultas.
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }


     function fulfillRequest(
        bytes32 requestId,
        bytes memory response,
        bytes memory
    ) internal override {
        if (ultimoRequestId == requestId) {
            nombrePiloto = string(response);
        }
        // Update the contract's state variables with the response and any errors

        // Emit an event to log the response
        emit Respuesta(requestId, nombrePiloto);
    }

}